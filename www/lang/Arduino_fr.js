'use strict';
goog.provide('Blockly.Msg.fr');
goog.require('Blockly.Msg');

// commun √† tous les blocs
Blockly.Msg.HELPURL="http://www.mon-club-elec.fr/pmwiki_reference_arduino/pmwiki.php?n=Main.ReferenceMaxi"; //ne pas traduire
Blockly.Msg.pin="sur la broche";
Blockly.Msg._AT="√†";
Blockly.Msg.AV="avant";
Blockly.Msg.AR="arri√®re";
Blockly.Msg.high="HIGH"; //ne pas traduire
Blockly.Msg.low="LOW"; //ne pas traduire
Blockly.Msg.right="droit";
Blockly.Msg.left="gauche";
Blockly.Msg.LetR="droit & gauche";
Blockly.Msg.direction="direction";
Blockly.Msg.vitesse="vitesse ";
Blockly.Msg.CAT_STOCKAGE = "‚äû Storage";
Blockly.Msg.CAT_numerique = "- Digital";
Blockly.Msg.CAT_analogique = "~ Analog";
Blockly.Msg.CAT_wifi = "Ôº† Wifi";
Blockly.Msg.CAT_TAB = "‚ñ¶ Table";
Blockly.Msg.CAT_ARDUINO_BASICS="‚àû Arduino basics"
Blockly.Msg.CAT_list = "‚ñ§ List";
Blockly.Msg.CAT_servo = "‚Ü∑ Servo";
Blockly.Msg.CAT_del = "‚òÑ LED";
Blockly.Msg.CAT_LOGIC = "‚áã Logic";
Blockly.Msg.CAT_MATH = "‚àë Math";
Blockly.Msg.CAT_TEXT = "‚ùù Text";
Blockly.Msg.CAT_VARIABLES = "‚Üù Variable";
Blockly.Msg.CAT_FUNCTIONS = "‚à¨ Function";
Blockly.Msg.CAT_ARDUINO = "‚àû Structure";
Blockly.Msg.CAT_ARDUINO_IN = "‚áÖ Input/Output";
Blockly.Msg.CAT_ARDUINO_OUT = "‚ò∫ Exit";
Blockly.Msg.CAT_ARDUINO_TIME = "‚óå Time";
Blockly.Msg.CAT_actionneur = "‚Üª Motor";
Blockly.Msg.CAT_com = "‚òé Communication";
Blockly.Msg.CAT_ARDUINO_COMM_SERIAL = "- Serial";
Blockly.Msg.CAT_ARDUINO_COMM_SOFTSERIAL = "- Soft Serial";
Blockly.Msg.CAT_ARDUINO_moteur="‚Üª Motor Stepper";
Blockly.Msg.CAT_ultrason = "‚á£ Sensor";
Blockly.Msg.CAT_bluetooth = "‚òè Bluetooth";
Blockly.Msg.CAT_ARDUINO_matrice8x8 = "‚ñë LED Mouth";
Blockly.Msg.CAT_ARDUINO_matrice16x8 = "‚ñë LED Eyes";
Blockly.Msg.CAT_DFRobot_SHIELD_LCDKEYPAD = "‚ñÄ LCD Screen";
Blockly.Msg.CAT_iot = "‚òÅ IoT";
Blockly.Msg.CAT_html = "‚úâ HTML";
Blockly.Msg.CAT_DFPLAYER = "‚ô´ Audio";
Blockly.Msg.CAT_OTTO = "‚äü Otto";
Blockly.Msg.CAT_OTTOH = "‚äü Humanoid";
Blockly.Msg.CAT_MASAYLO="‚äü Masaylo";
Blockly.Msg.CAT_ESCORNABOT="‚äü Escornabot";
Blockly.Msg.CAT_OLED_U8G = "‚ñÄ OLED";
Blockly.Msg.CAT_NEOPIXEL = "‚òÑ NeoPixel";
//wifi
Blockly.Msg.esp8266_init_tooltip="initialisation du module wifi et connection avec les param√®tres indiqu√©s";
Blockly.Msg.esp8266_1="Esp 8266";
Blockly.Msg.esp8266_2="ssid";
Blockly.Msg.esp8266_3="cl√©";
Blockly.Msg.esp8266_4="IP";
Blockly.Msg.esp8266_5="passerelle";
Blockly.Msg.esp8266_6="masque";
Blockly.Msg.esp8266_7=[["client", "client"],["serveur", "serveur"]];
Blockly.Msg.esp8266_8="port";
Blockly.Msg.esp8266_9=[["dynamique", "dynamic"],["statique", "static"]];
Blockly.Msg.esp8266_10="adressage";
Blockly.Msg.esp8266_recept_tooltip="reception";
Blockly.Msg.esp8266_url="http://julien.coron.free.fr/?p=928";
Blockly.Msg.esp8266_html_tooltip = "";
Blockly.Msg.esp8266_send_html_tooltip="";
Blockly.Msg.esp8266_send_html="envoyer la page HTML";
Blockly.Msg.esp8266_start_tooltip="";
Blockly.Msg.esp8266_start="d√©marrer le serveur";
Blockly.Msg.esp8266_request_tooltip="";
Blockly.Msg.esp8266_request="si dans la requ√™te on trouve";
Blockly.Msg.esp8266_request_container = "on trouve";
//INTERRUPTION
Blockly.Msg.LKL_ATTACHINTERRUPT_PIN='Interruption : quand un';
Blockly.Msg.LKL_DETACHINTERRUPT_PIN="d√©sactiver l'interruption sur la broche";
Blockly.Msg.LKL_TOOLTIP_INOUT_ATTACHINTERRUPT="Sp√©cifie une action √† r√©aliser lorsqu'une interruption externe (4 modes possibles) survient sur la broche 2 ou 3";
Blockly.Msg.LKL_TOOLTIP_INOUT_DETACHINTERRUPT="D√©sactive l'interruption externe sp√©cifi√©e pr√©c√©dement";
Blockly.Msg.LKL_MODE='est d√©tect√© sur la broche';
//FIELDDROPDOWN
Blockly.Msg.note=[["DO\u2084","261"],["RE\u2084","293"],["MI\u2084","329"],["FA\u2084","349"],["SOL\u2084","392"],["LA\u2084","440"],["SI\u2084","493"],["DO\u2085","523"],["RE\u2085","587"],["MI\u2085","659"],["FA\u2085","698"],["SOL\u2085","784"],["LA\u2085","880"]];
Blockly.Msg.tempo=[["1", "125"], ["2", "250"], ["4", "500"], ["8", "1000"], ["16", "2000"]];
Blockly.Msg.on_off=[["on", "LOW"], ["off", "HIGH"]];
Blockly.Msg.menublink=[["lentement", "1000"],["rapidement", "100"]];
Blockly.Msg.AV_AR=[[Blockly.Msg.AV, "FORWARD"],[Blockly.Msg.AR, "BACKWARD"]];//ne pas traduire
Blockly.Msg.times=[["secondes", "s"],["millisecondes", "m"],["microsecondes", "u"]];
Blockly.Msg.time=[["secondes", "s"],["millisecondes", "m"]];
Blockly.Msg.char_lcd=[["n¬∞1","1"],["n¬∞2","2"],["n¬∞3","3"],["n¬∞4","4"],["n¬∞5","5"],["n¬∞6","6"],["n¬∞7","7"],["n¬∞8","8"]];
Blockly.Msg.rxtx=[["2","2"],["3","3"],["4","4"],["5","5"],["6","6"],["7","7"],["8","8"],["9","9"],["10","10"],["11","11"],["12","12"],["13","13"]];
Blockly.Msg.FIELDDROPDOWN=[["1(√©tat haut)", Blockly.Msg.high], ["0(√©tat bas)",Blockly.Msg.low]];
Blockly.Msg.FIELDDROPDOWN_0_1=[["HAUT", Blockly.Msg.high], ["BAS",Blockly.Msg.low]];
Blockly.Msg.ligne=[["1", "0"], ["2", "1"]];
Blockly.Msg.colonne=[["1","0"],["2","1"],["3","2"],["4","3"],["5","4"],["6","5"],["7","6"],["8","7"],["9","8"],["10","9"],["11","10"],["12","11"],["13","12"],["14","13"],["15", "14"],["16", "15"]];
Blockly.Msg.FIELDDROPDOWN_ONOFF=[["allumer", Blockly.Msg.high], ["√©teindre",Blockly.Msg.low]];
Blockly.Msg.FIELDDROPDOWN_ONOFF_matrice=[["1", "true"], ["0", "false"]];
Blockly.Msg.FIELDDROPDOWN_av_ar=[[Blockly.Msg.AV, Blockly.Msg.high], [Blockly.Msg.AR,Blockly.Msg.low]];
Blockly.Msg.LKL_DROPDOWN=[['front montant', "RISING"], ['front descendant', "FALLING"], ["changement d'√©tat", "CHANGE"], ["√©tat bas",Blockly.Msg.low]];
Blockly.Msg.irq=[['front montant', "Pin.IRQ_RISING"], ['front descendant', "Pin.IRQ_FALLING"], ["√©tat haut", "Pin.IRQ_HIGH_LEVEL"], ["√©tat bas", "Pin.IRQ_LOW_LEVEL"]];
Blockly.Msg.menudht=[["humidit√©", "h"],["temp√©rature", "t"]];
Blockly.Msg.couleur=[["bleu", "bleu"],["jaune", "jaune"],["rouge", "rouge"],["vert", "vert"]];
Blockly.Msg.sens=[["avancer", "a"],["tourner √† droite", "d"],["tourner √† gauche", "g"]];
//capteur
Blockly.Msg.VL53L0X="D√©tecteur √† laser";
Blockly.Msg.VL53L0X_tooltip="initialise le d√©tecteur.\nD√©tecteur <--> Arduino\nSDA <--------> A4\nSCL <--------> A5";
Blockly.Msg.VL53L0X_distance="distance mesur√©e par laser";
Blockly.Msg.VL53L0X_distance_tooltip="VL530X :\nretourne la distance mesur√©e par laser en mm";
Blockly.Msg.bme280="D√©tecteur de pression atmosph√©rique";
Blockly.Msg.bme280_tooltip="initialise le d√©tecteur.\nD√©tecteur <--> Arduino\nSDA <--------> A4\nSCL <--------> A5";
Blockly.Msg.bme280_pressure="pression atmosph√©rique";
Blockly.Msg.bme280_pressure_tooltip="retourne la pression atmosph√©rique en hPa";
Blockly.Msg.inter="interrupteur sur";
Blockly.Msg.inter2="connect√© a la broche: ";
Blockly.Msg.inter_tooltip="retourne vrai (faux) si l'interrupteur est (n'est pas) sur la position indiqu√©e";
Blockly.Msg.mc005="pr√©sence d√©tect√©e sur la broche";
Blockly.Msg.mc005_tooltip="MC005:\nretourne vrai (faux) si une pr√©sence est (n'est pas) press√©";
Blockly.Msg.bp="bouton press√© sur la broche";
Blockly.Msg.bp_tooltip="retourne vrai (faux) si un bouton poussoir est (n'est pas) press√©";
Blockly.Msg.dht11_tooltip="DHT11 :\nretourne l'humidit√© de l'air (de 20 √† 80%) ou \n la temp√©rature (de 2 √† 50¬∞C)";
Blockly.Msg.dht22_tooltip="DHT22 :\nretourne l'humidit√© de l'air (de 0 √† 100%) ou \n la temp√©rature (de -40 √† 80¬∞C)";
Blockly.Msg.suiveur_ligne="ligne noire d√©tect√©e sur la broche";
Blockly.Msg.suiveur_ligne_tooltip= "CAP227 :\nretourne vrai (faux) si une ligne noire est (n'est pas) d√©tect√©e";
Blockly.Msg.light= "luminosit√© sur la broche";
Blockly.Msg.light_tooltip= "retourne une valeur en fonction de la luminosit√©\n0 : obscurit√©\n255 : pleine lumi√®re";
Blockly.Msg.hum= "humidit√© du sol sur la broche";
Blockly.Msg.hum_tooltip= "CAP 615 :\nretourne l'humidit√© du sol de 0 √† 100%";
Blockly.Msg.light_tooltip= "retourne une valeur en fonction de la luminosit√©\n0 : obscurit√©\n255 : pleine lumi√®re";
Blockly.Msg.grove_ldr= "luminosit√© sur la broche";
Blockly.Msg.grove_ldr_tooltip= "retourne la luminosit√© mesur√©e\n0 : aucune lumi√®re\n100 : lumi√®re tr√®s intense";
Blockly.Msg.potar= "position du curseur sur la broche";
Blockly.Msg.potar_tooltip= "retourne une valeur en fonction de la position du curseur\n0 : curseur √† gauche\n255 : curseur √† droite";
Blockly.Msg.lm35= "temp√©rature sur la broche";
Blockly.Msg.lm35_tooltip="LM35 :\nretourne la temp√©rature mesur√©e en degr√© celcius (de 0 √† 80¬∞)";
Blockly.Msg.ultrason_1="distance < limite";
Blockly.Msg.ultrason_2="retourne un √©tat Haut si la distance mesur√©e est inf√©rieur √† la limite";
Blockly.Msg.ultrason_distance1="distance mesur√©e par ultrason";
Blockly.Msg.ultrason_tooltip="HC-SR04 :\ncapteur √† ultrason qui permet de faire des mesures de distance (de 3 cm et 4 m)\nindiquer les broches de l'arduino sur lesquelles vont √™tre connect√©es TRIG et ECHO";
Blockly.Msg.ultrason="d√©tecteur √† ultrason";
Blockly.Msg.ultrason_distance2="HC-SR04 :\nretourne la distance mesur√©e en cm par le d√©tecteur √† ultrason";
Blockly.Msg.ultrason_helpurl="https://www.carnetdumaker.net/articles/mesurer-une-distance-avec-un-capteur-ultrason-hc-sr04-et-une-carte-arduino-genuino/";//ne pas traduire
Blockly.Msg.pir="mouvement d√©tect√© ";
Blockly.Msg.feu="flamme d√©tect√©e ";
Blockly.Msg.presence="obstacle d√©tect√© ";
Blockly.Msg.appui="appui digital ";
Blockly.Msg.pir_tooltip="HC-SR501 :\nretourne vrai (faux) si une pr√©sence est (n'est pas) d√©tect√©e";
Blockly.Msg.feu_tooltip="CAP168 :\nretourne vrai (faux) si une flamme est (n'est pas) d√©tect√©e";
Blockly.Msg.presence_tooltip="CAP711 :\nretourne vrai (faux) si un contact a (n'a pas) lieu";
Blockly.Msg.appui_tooltip="CAP831 :\nretourne vrai (faux) si un appui est (n'est pas) d√©tect√©";
Blockly.Msg.CAP661="impulsions sur la broche";
Blockly.Msg.CAP661_TOOLTIP="retourne le nombre de fentes (pleines + creuses) de la roue codeuse";
//bluetooth
Blockly.Msg.bluetooth1="si la donn√©e re√ßue par bluetooth";
Blockly.Msg.bluetooth1_tooltip= "r√©ception de donn√©es par bluetooth\nconnecter le module HC-06 sur les broches 0 et 1\net croiser les broches Rx et Tx";
Blockly.Msg.bluetooth2= "envoyer par bluetooth";
Blockly.Msg.bluetooth2_tooltip= "envoie des donn√©es par bluetooth\nconnecter le module HC-06 sur les broches 0 et 1\net croiser les broches Rx et Tx";
Blockly.Msg.bluetooth_init_tooltip="";
Blockly.Msg.bluetooth_helpurl="http://tiptopboards.free.fr/arduino_forum/viewtopic.php?f=2&t=57&sid=cedb66db91596dd8926d167142dbf307";//ne pas traduire
//√©cran LCD
Blockly.Msg.lcd_fond="fond";
Blockly.Msg.LCD="√©cran LCD";
Blockly.Msg.LCDi2c_tooltip="initialise l'√©cran LCD I2C, de 2 lignes et 16 caract√®res avec r√©tro-√©clairage RGB.\nAfficheur <--> Arduino\nSDA <--------> A4\nSCL <--------> A5";
Blockly.Msg.LCD_tooltip= "initialise l'√©cran LCD, de 2 lignes et 16 caract√®res, en indiquant les broches √† connecter";
Blockly.Msg.LCD_SHIELD_PRINT_HELPURL= "http://electroniqueamateur.blogspot.fr/2017/01/utiliser-un-afficheur-lcd-2-x-16-avec.html";
Blockly.Msg.LCD_SHIELD_PRINT_TEXT="afficher sur l'√©cran LCD";
Blockly.Msg.LCD_SHIELD_PRINT_TEXT_tooltip="affiche le texte √† l'emplacement indiqu√©";
Blockly.Msg.LCD_SHIELD_PRINT_TOOLTIP="√©cris le(s) texte(s) sur l'√©cran LCD";
Blockly.Msg.LCD_SHIELD_PRINT_INPUT1="ligne 1";
Blockly.Msg.LCD_SHIELD_PRINT_INPUT2="ligne 2";
Blockly.Msg.LCD_SHIELD_PRINT_INPUT3="ligne 3";
Blockly.Msg.LCD_SHIELD_PRINT_INPUT4="ligne 4";
Blockly.Msg.LCD_ADDRESS="direction";
Blockly.Msg.LCD_COLUMNS="colonnes";
Blockly.Msg.LCD_ROWS="lignes";
Blockly.Msg.LCD_line="ligne";
Blockly.Msg.LCD_col="colonne";
Blockly.Msg.LCD_raz="effacer l'√©cran LCD";
Blockly.Msg.LCD_raz_tooltip="efface l'√©cran";
Blockly.Msg.lcd_aff_symbole="afficher le symbole";
Blockly.Msg.lcd_aff_symbole_tooltip="affiche le symbole qui a √©t√© d√©fini auparavant";
Blockly.Msg.lcd_symbole="d√©clarer le symbole";
Blockly.Msg.lcd_symbole_tooltip="d√©finition d'un caract√®re pour l'afficheur LCD :\n 0 √©teint une pixel\n 1 allume une pixel";
// structure
Blockly.Msg.loop="Boucle";
Blockly.Msg.init="Initialisation";
Blockly.Msg.base_setup_loop="La fonction initialisation :\nElle est utilis√©e pour initialiser les variables, le sens des broches...\nElle n'est ex√©cut√©e qu'une seule fois\nLa fonction boucle :\nC'est la partie principale du programme, tous les blocs plac√©s ici s'√©x√©cuteront en boucle et ind√©finiment (plusieurs milliers de fois par seconde)";
Blockly.Msg.loop_tooltip="tous les blocs plac√©s ici s'√©x√©cuteront en boucle et ind√©finiment (plusieurs milliers de fois par seconde)";
Blockly.Msg.begin_tooltip="ce bloc permet de d√©clarer l'ordre dans lequel le programme doit s'ex√©cuter";
Blockly.Msg.begin="D√âBUT du programme";
Blockly.Msg.def="D√©claration";
Blockly.Msg.def_tooltip="tous les blocs plac√©s ici ne s'√©x√©cuteront qu'une seule fois, c'est ici qu'on configure les diff√©rents capteurs ou actionneurs";
Blockly.Msg.END="FIN du programme";
Blockly.Msg.END_tooltip="Stoppe le programme, les blocs plac√©s √† la suite seront ignor√©s";
Blockly.Msg.code_tooltip="Tapez ici une instruction qui ne se trouve pas sous forme de blocs";
//matrice
Blockly.Msg.matriceLC="mettre la DEL, de la matrice";
Blockly.Msg.matrice_create_aff="Cr√©er le bloc 'afficher le symbole %1'";
Blockly.Msg.matrice_create_symbole="Cr√©er le bloc 'd√©clarer le symbole %1'";
Blockly.Msg.matrice="matrice";
Blockly.Msg.matrice8x8_tooltip="Initialisation de la matrice √† 64 DEL, il faut indiquer les broches de l'arduino sur lesquelles vont √™tre connect√©es DIN, CLK, CS";
Blockly.Msg.matrice8x8_symbole="d√©clarer le symbole";
Blockly.Msg.matrice8x8_symbole_tooltip="d√©finition d'un symbole pour la matrice :\n 0 √©teint une DEL\n 1 allume une DEL";
Blockly.Msg.matrice8x8_efface="√©teindre les DEL de la matrice";
Blockly.Msg.matrice8x8_aff="afficher le symbole";
Blockly.Msg.matrice8x8_scroll="√âcrire du texte";
Blockly.Msg.matrice8x8_scroll_tooltip="√âcrire un texte d√©filant sur l'√©cran\n(majuscules, 9 caract√®res";
Blockly.Msg.matrice8x8_binaire_tooltip="1 allume une DEL de la matrice et 0 l'√©teint";
Blockly.Msg.matrice8x8_del_tooltip= "Allume (√©teint) une DEL de la matrice en indiquant les coordonn√©es de celle-ci\nAttention la num√©rotation commence √† 0";
Blockly.Msg.matrice8x8_aff_tooltip= "Affiche le symbole qui aura √©t√© pr√©alablement d√©fini";
Blockly.Msg.matrice8x8_efface_tooltip= "Eteint toutes les DEL de la matrice";
Blockly.Msg.matrice8x8_helpurl="http://tiptopboards.free.fr/arduino_forum/viewtopic.php?t=6&p=6";
Blockly.Msg.matrice16x8_tooltip="Initialisation de la matrice √† 128 DEL.\nMatrice <--> Arduino\nSDA <--------> A4\nSCL <--------> A5";
Blockly.Msg.matrice16x8_symbole="d√©clarer le symbole";
Blockly.Msg.matrice16x8_symbole_tooltip="d√©finition d'un symbole pour la matrice :\n 0 √©teint une DEL\n 1 allume une DEL";
Blockly.Msg.matrice16x8_efface="√©teindre les DEL de la matrice";
Blockly.Msg.matrice16x8_aff="afficher le symbole";
Blockly.Msg.matrice16x8_binaire_tooltip="1 allume une DEL de la matrice et 0 l'√©teint";
Blockly.Msg.matrice16x8_del_tooltip= "Allume (√©teint) une DEL de la matrice en indiquant les coordonn√©es de celle-ci\nAttention la num√©rotation commence √† 0";
Blockly.Msg.matrice16x8_aff_tooltip= "Affiche le symbole qui aura √©t√© pr√©alablement d√©fini";
Blockly.Msg.matrice16x8_efface_tooltip= "Eteint toutes les DEL de la matrice";
Blockly.Msg.matrice16x8_helpurl="http://";
Blockly.Msg.matrice8x8_scroll_tooltip="fait d√©filer le texte indiqu√© sur les matrices";
Blockly.Msg.matrice8x8_scroll="faire d√©filer";
//temps
Blockly.Msg.millis0 ="temps √©coul√© en";
Blockly.Msg.millis1="dur√©e en";
Blockly.Msg.millis2="depuis le d√©but";
Blockly.Msg.millis_tooltip="retourne le temps √©coul√© depuis que le programme a d√©marr√©";
Blockly.Msg.millis_start="commencer un chronom√©trage en";
Blockly.Msg.millis_start_tooltip="commence un chronom√©trage √† partir du moment o√π le bloc est positionn√©";
Blockly.Msg.chrono_tooltip="retourne le temps √©coul√© depuis que le chronom√®tre a √©t√© lanc√©";
Blockly.Msg.ARDUINO_INOUT_Pulsein="retourne la dur√©e en microsecondes d'une impulsion de niveau HAUT ou BAS appliqu√©e sur une broche. Si le param√®tre valeur est HAUT (BAS), le bloc attend que la broche passe √† HAUT (BAS), commence alors le chronom√©trage, attend que la broche repasse au niveau BAS (HAUT) et stoppe alors le chronom√©trage";
Blockly.Msg.ARDUINO_BASE_DELAY="attendre";
Blockly.Msg.ARDUINO_BASE_DELAY_TOOLTIP="sp√©cifier le temps d'attente en secondes, millisecondes ou microsecondes.\nLe programe ne fait rien d'autre pendant ce laps de temps";
Blockly.Msg.ARDUINO_SINCE_PROGRAM_STARTED_TOOLTIP="retourne la dur√©e en millisecondes, secondes ou microsecondes depuis que le programme a commenc√©";
Blockly.Msg.ARDUINO_PULSEIN="dur√©e de l'√©tat";
Blockly.Msg.tempo_helpurl="http://www.mon-club-elec.fr/pmwiki_reference_arduino/pmwiki.php?n=Main.ExempleBlinkWithoutDelay";
Blockly.Msg.tempo_tooltip="Ce bloc v√©rifie si le temps indiqu√© est arriv√©, si c'est le cas alors il √©x√©cute les blocs plac√©s √† l'int√©rieur. Contrairement au bloc 'attendre' celui-ci n'est pas bloquant.";
Blockly.Msg.tempo1="toutes les";
Blockly.Msg.lp2i_u8g_draw_string = "OLED I2C display";
Blockly.Msg.lp2i_u8g_draw_string_Text = "text to display =";
Blockly.Msg.lp2i_u8g_draw_string_X = "raw x (127 max) =";
Blockly.Msg.lp2i_u8g_draw_string_Y = "line y (63 max) =";
Blockly.Msg.lp2i_u8g_draw_4strings = "OLED I2C display";
Blockly.Msg.lp2i_u8g_draw_4strings_texts_to_display = "texts to display :";
Blockly.Msg.lp2i_u8g_draw_4strings_Text_line1 = "line 1 =";
Blockly.Msg.lp2i_u8g_draw_4strings_Text_line2 = "line 2 =";
Blockly.Msg.lp2i_u8g_draw_4strings_Text_line3 = "line 3 =";
Blockly.Msg.lp2i_u8g_draw_4strings_Text_line4 = "line 4 =";
Blockly.Msg.lp2i_u8g_print = "OLED I2C display";
Blockly.Msg.lp2i_u8g_print_N = "Number to display ="
Blockly.Msg.lp2i_u8g_print_X = "raw x (127 max) =";
Blockly.Msg.lp2i_u8g_print_Y = "line y (63 max) =";
Blockly.Msg.lp2i_u8g_4draw_print = "OLED I2C display";
Blockly.Msg.lp2i_u8g_4draw_print_to_display = "to display :";
Blockly.Msg.lp2i_u8g_4draw_print_Text_line1 = "line 1 =";
Blockly.Msg.lp2i_u8g_4draw_print_N1 = "Number 1 (at end) ="
Blockly.Msg.lp2i_u8g_4draw_print_Text_line2 = "line 2 =";
Blockly.Msg.lp2i_u8g_4draw_print_N2 = "Number 2 (at end) ="
Blockly.Msg.lp2i_u8g_4draw_print_Text_line3 = "line 3 =";
Blockly.Msg.lp2i_u8g_4draw_print_N3 = "Number 3 (at end) ="
Blockly.Msg.lp2i_u8g_4draw_print_Text_line4 = "line 4 =";
Blockly.Msg.lp2i_u8g_4draw_print_N4 = "Number 4 (at end) ="
//DEL
Blockly.Msg.ARDUINO_INOUT_BUILDIN_LED_INPUT="la DEL de la carte";
Blockly.Msg.ARDUINO_INOUT_BUILDIN_LED_TOOLTIP="√©teint ou allume la DEL sur la carte Arduino";
Blockly.Msg.blink="faire clignoter la DEL de la carte";
Blockly.Msg.blink_tooltip= "la DEL de la carte clignote 1 ou 10 fois par seconde";
Blockly.Msg.del="la DEL connect√©e √† la broche";
Blockly.Msg.del_tooltip="allume (√©teint) la DEL connect√©e √† la broche indiqu√©e";
Blockly.Msg.bargraphe="bargraphe";
Blockly.Msg.bargraphe_allume="allumer les DEL du bargraphe jusqu'√†";
Blockly.Msg.bargraphe_allume_tooltip="0 n'allume aucune DEL\n2,5 allume les 2 premi√®res DEL et la 3√®me √† moiti√©\n10 allume toutes les DEL";
Blockly.Msg.bargraphe_tooltip="module bargraphe compos√© de 10 DEL (8 vertes, 1 jaune et 1 rouge), il faut indiquer les broches de l'arduino sur lesquelles vont √™tre connect√©es DCKI et DI";
Blockly.Msg.rvb_init="DEL rvb";
Blockly.Msg.rvb_init_tooltip="indiquer les broches PWM √† connecter √† la DEL RVB";
Blockly.Msg.rvb_set="afficher la couleur";
Blockly.Msg.rvb_set_tooltip="affiche la couleur en fonction des 3 composantes (rouge, vert, bleu)";
Blockly.Msg.pixel1="pixel RVB";
Blockly.Msg.pixel2="mettre √† jour les pixels";
Blockly.Msg.pixel3="avec la couleur";
Blockly.Msg.pixel4="nombre";
Blockly.Msg.pixel5="r√©gler la luminosit√© des pixels √†";
Blockly.Msg.pixel6="r√©gler la pixel";
Blockly.Msg.pixel7="allumer les pixels";
Blockly.Msg.pixel8="√©teindre les pixels";

Blockly.Msg.pixel1_tooltip="module neopixel RVB\nindiquer la broche √† connecter et le nombre de pixels";
Blockly.Msg.pixel2_tooltip="affiche les modifications apport√©es";
Blockly.Msg.pixel3_tooltip="choisir la pixel √† allumer ainsi que sa couleur\nAttention la num√©rotation commence √† 0";
Blockly.Msg.pixel4_tooltip="√©teint toutes les pixels";
Blockly.Msg.pixel5_tooltip="r√®gle la luminosit√© des pixels (de 0 √† 255)";
//sortie
Blockly.Msg.ARDUINO_INOUT_DIGITAL_WRITE_INPUT1="mettre la broche NUMERIQUE";
Blockly.Msg.ARDUINO_INOUT_DIGITAL_WRITE_TOOLTIP="√©crire un √©tat logique (0 ou 1) sur la broche indiqu√©e";
Blockly.Msg.toggle="basculer l'√©tat de la broche";
Blockly.Msg.toggle_tooltip="Toggle :\n√©crire un √©tat logique 0 si auparavant il y avait un √©tat 1 (et inversement) sur la sortie sp√©cifi√©e";
Blockly.Msg.ARDUINO_INOUT_ANALOG_WRITE_INPUT1="mettre la broche PWM";
Blockly.Msg.ARDUINO_INOUT_ANALOG_WRITE_TOOLTIP="envoyer une valeur comprise entre 0 et 255 sur la broche indiqu√©e";
//entr√©e
Blockly.Msg.ARDUINO_INOUT_DIGITAL_READ_INPUT="√©tat de la broche NUMERIQUE";
Blockly.Msg.in_pullup ="Pull-Up";
Blockly.Msg.in_pullup_tooltip="retourne l'√©tat logique (0 ou 1) de la broche indiqu√©e\nretourne 1(√©tat haut) par d√©faut si pull-up activ√©";
Blockly.Msg.ARDUINO_INOUT_DIGITAL_READ_TOOLTIP="retourne l'√©tat logique (0 ou 1) de la broche indiqu√©e";
Blockly.Msg.ARDUINO_INOUT_ANALOG_READ_INPUT="valeur de la broche ANALOGIQUE";
Blockly.Msg.ARDUINO_INOUT_ANALOG_READ_TOOLTIP="retourne une valeur comprise entre 0 et 1023";
//audio
Blockly.Msg.play="jouer";
Blockly.Msg.play_tooltip="joue la note indiqu√©e pendant le temps indiqu√©\n1 temps = 125ms\n2 temps = 250ms\n4 temps = 500ms...";
Blockly.Msg.play_helpurl="";
Blockly.Msg.beep="√©mettre un bip sur la broche";
Blockly.Msg.beep_TOOLTIP="√©met un bip (√† 440Hz pendant 1s) sur la broche selectionn√©e";
Blockly.Msg.ARDUINO_TONE_INPUT1="√©mettre un son sur la broche";
Blockly.Msg.ARDUINO_TONE_INPUT2="fr√©quence (Hz)";
Blockly.Msg.ARDUINO_TONE_INPUT3="dur√©e (ms)";
Blockly.Msg.ARDUINO_TONE_TOOLTIP="√©mettre un son sur la broche selectionn√©e, √† la fr√©quence d√©sir√©e et pendant la dur√©e souhait√©e";
Blockly.Msg.ARDUINO_NOTONE_INPUT="stopper le son sur la broche";
Blockly.Msg.ARDUINO_NOTONE_TOOLTIP="arr√™ter le son sur la broche selectionn√©e";
Blockly.Msg.lp2i_mp3_helpurl="http://ouilogique.com/tests_DFPlayer/";
Blockly.Msg.lp2i_mp3_Volume="volume [0-48]";
Blockly.Msg.lp2i_mp3_autoplay="lecture automatique";
Blockly.Msg.lp2i_mp3="lecteur MP3";
Blockly.Msg.lp2i_mp3_tooltip="DFPlayer Mini mp3 :\ninitialisation du module, du volume et du mode de fonctionnement\nModule MP3 <--> Arduino\nRx(2) <---------------> Tx(1)";
Blockly.Msg.lp2i_mp3_play="lire le fichier mp3";
Blockly.Msg.lp2i_mp3_play_track_tooltip="joue le morceau indiqu√©";
Blockly.Msg.lp2i_mp3_play_tooltip="joue le morceau en cours";
Blockly.Msg.lp2i_mp3_pause="mettre le fichier mp3 en pause";
Blockly.Msg.lp2i_mp3_pause_tooltip="stoppe le morceau en cours" ;
Blockly.Msg.lp2i_mp3_prev="lire le fichier mp3 pr√©c√©dent";
Blockly.Msg.lp2i_mp3_prev_tooltip="joue le morceau pr√©c√©dent";
Blockly.Msg.lp2i_mp3_vol="mettre le volume √†";
Blockly.Msg.lp2i_mp3_vol_tooltip="mettre le volume √† la valeur indiqu√©e [0-48]";
Blockly.Msg.lp2i_mp3_next="lire le fichier mp3 suivant";
Blockly.Msg.lp2i_mp3_next_tooltip="joue le morceau suivant";
//servomoteur
Blockly.Msg.ARDUINO_SERVO_MOVE_INPUT1="orienter le servomoteur";
Blockly.Msg.ARDUINO_SERVO_MOVE_DEGREE="angle [0-180]";
Blockly.Msg.ARDUINO_SERVO_MOVE_TOOLTIP="rotation possible entre 0 et 180 degr√©s";
Blockly.Msg.ARDUINO_SERVO_ROT_CONTINUE_TEXT="actionner le servomoteur en continue";
Blockly.Msg.ARDUINO_SERVO_ROT_CONTINUE_TOOLTIP="actionne le servomoteur connect√© √† la broche sp√©cifi√©e, √† la vitesse indiqu√©e et dans le sens s√©lectionn√©";
//moteur
Blockly.Msg.mot_tooltip="Shield contr√¥leur de moteurs L293D :\nactionne les deux moteurs (M1 et M2) pour avancer ou tourner, la vitesse peut √™tre r√©gl√©e entre 0 et 90";
Blockly.Msg.mot_stop="arr√™ter";
Blockly.Msg.mot_stop_tooltip="Shield contr√¥leur de moteurs L293D :\nstoppe les deux moteurs (M1 et M2)";
Blockly.Msg.moteur="actionner le moteur ";
Blockly.Msg.moteurstop="arr√™ter le moteur ";
Blockly.Msg.moteur_tooltip="met en route le moteur √† courant continu connect√© √† la broche indiqu√©e, √† la vitesse indiqu√©e\nvitesse=0 --> arr√™t du moteur";
Blockly.Msg.moteurdagu_tooltiprs040= "Carte RS 040 :\nactionne une des 2 sorties pour piloter des moteurs √† courant continu, la vitesse peut √™tre r√©gl√©e entre 0 et 90";
Blockly.Msg.moteurdagu_tooltiprs040stop= "Carte RS 040 :\nstoppe un des 2 moteurs";
Blockly.Msg.moteurdagu_tooltiprs027= "Carte RS 027 :\nactionne une des 2 sorties pour piloter des moteurs √† courant continu, la vitesse peut √™tre r√©gl√©e entre 0 et 90";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR1="v1 - Moteur CC";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR2="v2 - Moteur CC";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR_DIRECTION="direction";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR_VITESSE=Blockly.Msg.vitesse+"[0-255]";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_AVANT="avant";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_ARRIERE="arri√®re";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_STOP="stop";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_PAP1="v1 - moteur Pas-√†-pas";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_PAP2="v2 - moteur Pas-√†-pas";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_CONNECT="broche";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR_PPT="pas par tour";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR_RPM=Blockly.Msg.vitesse+"(RPM)";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTOR_NB_PAS="nombre de pas";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTORDC1="moteur DC 1";
Blockly.Msg.ADAFRUIT_MOTORSHIELD_MOTORDC2="moteur DC 2";
Blockly.Msg.m_pap="Moteur pas √† pas";
Blockly.Msg.m_pap_step="pas";
Blockly.Msg.m_pap_step1="avancer de";
Blockly.Msg.m_pap_tooltip="Initialisation d'un moteur pas √† pas.\nIndiquer le nombre de pas, la vitesse en tr/min et les broches √† connecter";
Blockly.Msg.m_pap_step_tooltip="actionne le moteur pas √† pas du nombre de pas indiqu√©, l'instruction suivante ne sera √©x√©cut√©e qu'une fois la rotation du moteur effectu√©e";
//com s√©rie
Blockly.Msg.Serial_Init="port s√©rie sur";
Blockly.Msg.Serial_Init_tooltip="Fixe le d√©bit de communication en nombre de caract√®res par seconde pour la communication s√©rie";
Blockly.Msg.Serial_Write="envoyer sur le port s√©rie";
Blockly.Msg.Serial_write_tooltip="Envoie des donn√©es sur le port s√©rie";
Blockly.Msg.Serial_Write2 = "√©criver ligne: ";
Blockly.Msg.Serial_write2_tooltip = "√©criver ligne sur le port s√©rie avec retour chariot";

Blockly.Msg.Serial_read="donn√©e lue sur le port s√©rie";
Blockly.Msg.Serial_read_tooltip="retourne le premier octet de donn√©e entrant disponible dans le port s√©rie, ou -1 si aucune donn√©e n'est disponible";
Blockly.Msg.Serial_available="quantit√© de donn√©es sur le port s√©rie";
Blockly.Msg.Serial_available_tooltip="retourne le nombre d'octet disponible dans la file d'attente du port s√©rie, ou 0 si rien n'est disponible";
Blockly.Msg.Serial_saut="un saut de ligne";
Blockly.Msg.Serial_saut_tooltip="retourne un saut de ligne sur le moniteur s√©rie";
Blockly.Msg.Serial_space="un s√©parateur";
Blockly.Msg.Serial_space_tooltip="retourne un espace sur le moniteur s√©rie";
Blockly.Msg.repl_read="commande entr√©e par l'utilisateur";
//com logicielle
Blockly.Msg.SSERIAL_Init="port logiciel sur Rx";
Blockly.Msg.SSERIAL_tooltip="Cr√©ation d'un nouveau port de communication en utilisant les broches et la vitesse sp√©cifi√©es";
Blockly.Msg.SSERIAL_Read="donn√©e lue sur le port logiciel";
Blockly.Msg.SSERIAL_Read_tooltip="retourne le premier octet de donn√©e entrant disponible dans le port logiciel, ou -1 si aucune donn√©e n'est disponible";
Blockly.Msg.SSERIAL_Write="envoyer sur le port logiciel";
Blockly.Msg.SSERIAL_Write_tooltip="Envoie des donn√©es sur le port logiciel";
Blockly.Msg.SSerial_Write2= "envoyer sur le port software";
Blockly.Msg.SSerial_write2_tooltip = "Envoie des donn√©es sur le port software";

Blockly.Msg.SSERIAL_Read_tooltip="retourne le premier octet de donn√©e entrant disponible dans le port logiciel, ou -1 si aucune donn√©e n'est disponible";
Blockly.Msg.SSERIAL_Available="quantit√© de donn√©es sur le port logiciel";
Blockly.Msg.SSERIAL_Available_tooltip="retourne le nombre d'octet disponible dans la file d'attente du port logiciel, ou 0 si rien n'est disponible";
// stockage
Blockly.Msg.STOCK1="stocker la donn√©e";
Blockly.Msg.STOCK2="√† l'adresse";
Blockly.Msg.STOCK_TOOLTIP="permet d'√©crire une donn√©e (8 bits ou un octet) dans la m√©moire EEPROM, √† l'adresse indiqu√©e\nATmega328p et ATmega32u4 --> 1024 octets\nATmega2560 --> 4096 octets";
Blockly.Msg.STOCK3="lire donn√©e √† l'adresse";
Blockly.Msg.STOCK3_TOOLTIP="retourne la donn√©e stock√©e √† l'adrese indiqu√©e (8 bits ou un octet)\nATmega328p et ATmega32u4 --> 1024 octets\nATmega2560 --> 4096 octets";
////////////OTTO DIY Robot////////// ONLY TRANSLATE THE LEFT PART INSIDE ["THIS YES" ,NOT]
Blockly.Msg.OTTO9_HOME_TEXT = "home";
Blockly.Msg.OTTO9_HOME_TOOLTIP = "Otto goes to home position straight";
Blockly.Msg.OTTO9_DIY_URL = "https://wikifactory.com/+OttoDIY/otto-diy";// do not translate
Blockly.Msg.OTTO9_HUMANOID_URL = "https://wikifactory.com/+OttoDIY/humanoid";// do not translate
Blockly.Msg.OTTO9_CALIBRATION='calibrate ';
Blockly.Msg.OTTO9_CALIBRATION_LEG='leg ';
Blockly.Msg.OTTO9_CALIBRATION_FOOT='foot ';
Blockly.Msg.OTTO9_CALIBRATION_ARM='arm ';
Blockly.Msg.OTTO9_CALIBRATION_TOOLTIP='use small positive and negative values iteratively,change gradually until is completely straight (90¬∫)';
Blockly.Msg.OTTO9_EEPROM_TEXT= 'save Trims on EEPROM';
Blockly.Msg.OTTO9_EEPROM_TOOLTIP= 'Use only after completely straight(90¬∫) one time, delete this BLOCK after for further programming';
Blockly.Msg.OTTO9_MOVE_TEXT = "move";
Blockly.Msg.OTTO9_MOVE_TOOLTIP = "Otto basic movements";
Blockly.Msg.OTTO9_MOVE_CHOICE = [["‚Üë forward", "FORWARD"], ["‚Üì backward", "BACKWARD"], ["‚Ü∫ turn left", "LEFT"], ["‚Üª turn right", "RIGHT"], ["bend to the left", "BENDLEFT"], ["bend to the right", "BENDRIGHT"], ["shake left leg", "SHAKELEFT"], ["shake right leg", "SHAKERIGHT"], ["up", "jump"]];
Blockly.Msg.OTTO9_MOVEW_CHOICE = [["‚Üë forward", "FORWARD"], ["‚Üì backward", "BACKWARD"], ["‚Ü∫ turn left", "LEFT"], ["‚Üª turn right", "RIGHT"]];
Blockly.Msg.OTTO9_MOVE_SPEED_TEXT = "speed";
Blockly.Msg.OTTO9_MOVE_SPEED_CHOICE = [["normal", "1000"],["slow", "2000"],["very slow", "3000"] , ["fast", "750"], ["very fast", "500"], ["way to fast", "250"]];
Blockly.Msg.OTTO9_MOVEW_SPEED_CHOICE = [["normal", "45"],["slow", "20"],["very slow", "10"] , ["fast", "60"], ["very fast", "90"]];
Blockly.Msg.OTTO9_DANCE_TEXT = "dance";
Blockly.Msg.OTTO9_DANCE_TOOLTIP = "Otto dance!";
Blockly.Msg.OTTO9_DANCE_CHOICE = [["moonwalk ‚üµ", "moonwalkerLEFT"],  ["moonwalk ‚ü∂", "moonwalkerRIGHT"],["crossing ‚üµ", "crusaitoLEFT"],["crossing ‚ü∂", "crusaitoRIGHT"], ["flapping ‚Üë", "flappingFRONT"], ["flapping ‚Üì", "flappingBACK"]];
Blockly.Msg.OTTO9_DANCE_SIZE_TEXT = "size";
Blockly.Msg.OTTO9_DANCE_SIZE_CHOICE = [["normal", "25"], ["little", "10"], ["big", "40"]];
Blockly.Msg.OTTO9_DO_TEXT = "do";
Blockly.Msg.OTTO9_DO_TOOLTIP = "Otto complex movements";
Blockly.Msg.OTTO9_DO_CHOICE = [ ["swing", "swing"], ["updown", "updown"], ["tiptoeSwing", "tiptoeSwing"], ["jitter", "jitter"], ["ascendingTurn", "ascendingTurn"]];
Blockly.Msg.OTTO9_GESTURE_TEXT = "gesture";
Blockly.Msg.OTTO9_GESTURE_TOOLTIP = "Emotional sounds combined with movements";
Blockly.Msg.OTTO9_GESTURE_CHOICE = [["üòÉ happy1", "OttoSuperHappy"],["üôÇ happy2", "OttoHappy"], ["üôÅ sad", "OttoSad"], ["üò¥ sleep", "OttoSleeping"], ["üòï confused", "OttoConfused"], ["üò∞ fretful", "OttoFretful"], ["üòç love", "OttoLove"], ["üò° angry", "OttoAngry"], ["ü§© magic", "OttoMagic"], ["üòê wave", "OttoWave"], [" üòé victory", "OttoVictory"], ["üòû fail", "OttoFail"], ["üí© fart", "OttoFart"]];
Blockly.Msg.OTTO9_SOUND_TEXT = "sound";
Blockly.Msg.OTTO9_SOUND_TOOLTIP = "Emotional sounds";
Blockly.Msg.OTTO9_SOUND_CHOICE = [ ["üòÉ happy1", "S_superHappy"], ["üôÇ happy2", "S_happy"], ["üòä happy3", "S_happy_short"], ["üôÅ sad", "S_sad"], ["üòï confused", "S_confused"], ["ü§ó cuddly", "S_cuddly"], ["üòÆ Oh", "S_OhOoh"], ["üòØ OhOoh", "S_OhOoh2"], ["üò≤ surprise", "S_surprise"],["ü§ñ connect", "S_connection"], [" ü§ñ disconnect", "S_disconnection"], ["üëá push", "S_buttonPushed"], ["‚ùó 1", "S_mode1"], ["‚ùó‚ùó 2", "S_mode2"], ["‚ùó‚ùó‚ùó 3", "S_mode3"], ["üí§ sleep", "S_sleeping"], ["üí© fart1", "S_fart1"], ["üí© fart2", "S_fart2"], ["üí© fart3", "S_fart3"],];
Blockly.Msg.OTTO9_GETDISTANCE_TEXT = "distance [cm]";
Blockly.Msg.OTTO9_GETDISTANCE_TOOLTIP = "Ranging distance between 2cm to 400cm";
Blockly.Msg.OTTO9_GETOBSTACLE_TEXT = "obstacle";
Blockly.Msg.OTTO9_OBSTACLE_CHOICE = [["close", "10"],["very close", "3"],["far", "30"]];
Blockly.Msg.OTTO9_GETNOISE_TEXT = "noise measured";
Blockly.Msg.OTTO9_GETNOISE_TOOLTIP = "100 is quiet, 500 noise and more than 1000 is loud, also adjust the sensor trimpot sensibility";
Blockly.Msg.OTTO9_GETTOUCH_TEXT = "touch";
Blockly.Msg.OTTO9_GETTOUCH_TOOLTIP = "use if conditional";
Blockly.Msg.OTTO9_GETG_TEXT = "motion";
Blockly.Msg.OTTO9_MOUTH_TEXT = "mouth";
Blockly.Msg.OTTO9_MOUTH_TOOLTIP = "mouth emotion for the 8x8 LED matrix #0-30";
Blockly.Msg.OTTO9_MOUTH_CHOICE = [["üòÉ happy1", "happyOpen"],["üôÇ happy2", "happyClosed"], ["üòä smile", "smile"], ["üò¶ sad1", "23"], ["üôÅ sad2", "24"], ["üòÆ surprise", "smallSurprise"], ["üò≤ Surprise2", "bigSurprise"], ["üòï confused", "confused"],["üòõ tongue", "tongueOut"],["üôÉ silly", "culito"],  ["üòë serious", "lineMouth"], ["üôÑ upset", "21"], ["üíñ heart", "heart"], ["ü¶á v1", "vamp1"], ["ü¶á v2", "vamp2"], ["‚ùå no", "xMouth"], ["‚úÖ OK", "okMouth"],["‚ùì?", "27"], ["‚ö° thunder", "thunder"]];
Blockly.Msg.OTTO9_EYES_TEXT = "eyes";
Blockly.Msg.OTTO9_EYES_TOOLTIP = "eyes emotion for the 16x8 i2C LED matrix ";
Blockly.Msg.OTTO9_EYES_CHOICE = [["üòÉ happy1", "happy_bmp"],["üôÇ happy2", "eyes_bmp"], ["üò¶ sad", "sad_bmp"], ["üò° angry1", "angry_bmp"], ["üò° angry2", "angry2_bmp"], ["üò∞ freetful", "freetful_bmp"], ["üòï confused", "confused_bmp"],["üò¥ sleep", "sleep_bmp"],["üòç love", "love_bmp"],  ["üòë wave", "wave_bmp"], ["ü§© magic", "magic_bmp"], ["üòû fail", "fail_bmp"], ["ü§ñ logo", "logo_bmp"], ["‚ùå‚ùå no", "XX_bmp"], ["x x", "xx_bmp"],["‚ñâ", "full_bmp"]];
Blockly.Msg.OTTO9_EYESTEXT_TEXT = "eyes text";
Blockly.Msg.OTTO9_EYES_CLEAR_TEXT = " clear eyes";
Blockly.Msg.OTTO9_MATRIX_TOOLTIP = "limited to CAPITALS A to Z NUMBERS 0 to 9 : ; < >  = @, max.9 characters";
Blockly.Msg.OTTO9_MATRIXTEXT_TEXT = "mouth text";
Blockly.Msg.OTTO9_CLEAR_TEXT = " clear mouth";
Blockly.Msg.OTTO9_CLEAR_TOOLTIP = "Turn off all LEDs of the mouth matrix 8x8";
Blockly.Msg.OTTO9_ARMS_TEXT = "arms";
Blockly.Msg.OTTO9_ARMS_TOOLTIP = "move the arms!";
Blockly.Msg.OTTO9_ARMS_CHOICE = [["hands up", "HANDSUP"], ["handwave left", "HANDWAVE1"], ["handwave right", "HANDWAVE2"]];
////////////MASAYLO Robot////////// ONLY TRANSLATE THE LEFT PART INSIDE ["THIS YES" ,NOT]
Blockly.Msg.MASAYLO_START_TEXT = "Start";
Blockly.Msg.MASAYLO_START_TOOLTIP = "Declare a new robot type Masaylo";
Blockly.Msg.MASAYLO_URL = "https://github.com/agomezgar/masaylo";// do not translate
Blockly.Msg.MASAYLO_STARTPERS_TEXT="Start in pins:"
Blockly.Msg.MIA="Left A: ";
Blockly.Msg.MIB="Left B: ";
Blockly.Msg.MDA="Right A: ";
Blockly.Msg.MDB="Right B: ";
Blockly.Msg.MASAYLO_STARTPERS_TOOLTIP="Indicate pins if you didn't use default connections";
Blockly.Msg.MASAYLO_STARTPERS_URL="https://github.com/agomezgar/masaylo/blob/master/pinout/pinoutMasaylo.png";
Blockly.Msg.MASAYLO_MOVER_TEXT="Move: ";
Blockly.Msg.MASAYLO_MOVE_CHOICE = [["‚Üë forward", "FORWARD"], ["‚Üì backward", "BACKWARD"], ["‚Ü∫ turn left", "LEFT"], ["‚Üª turn right", "RIGHT"], ["stop", "STOP"]];
Blockly.Msg.MASAYLO_VELOCITY_CHOICE = [["Top", "TOP"], ["Quick", "QUICK"], ["Medium", "MEDIUM"], ["Slow", "SLOW"], ["Almost stopped", "SLOWER"]];

Blockly.Msg.MASAYLO_MOVER_TOOLTIP="Make a good choice!";
Blockly.Msg.MASAYLO_BTINIT_TEXT="Init the BT Controller";
Blockly.Msg.MASAYLO_Tx_TEXT="Tx: ";
Blockly.Msg.MASAYLO_Rx_TEXT="Rx: ";
Blockly.Msg.MASAYLO_BT_TOOLTIP="Maybe you would want BT commnunication... ";
Blockly.Msg.MASAYLO_GETDISTANCE_TEXT="Distance: ";
Blockly.Msg.MASAYLO_GETDISTANCE_TOOLTIP="Use a US sensor to detect obstacles";
Blockly.Msg.MASAYLO_GETBLACKLEFT_TEXT="Black on left";
Blockly.Msg.MASAYLO_GETBLACKLEFT_TOOLTIP="Returns 'true' when black colour is detected on left side";
Blockly.Msg.MASAYLO_GETBLACKRIGHT_TEXT="Black on right";
Blockly.Msg.MASAYLO_GETBLACKRIGHT_TOOLTIP="Returns 'true' when black colour is detected on right side";
Blockly.Msg.MASAYLO_GETBLANKLEFT_TEXT="White on left";
Blockly.Msg.MASAYLO_GETBLANCKLEFT_TOOLTIP="Returns 'true' when white colour is detected on left side";
Blockly.Msg.MASAYLO_GETBLANKRIGHT_TEXT="White on right";
Blockly.Msg.MASAYLO_GETBLANKRIGHT_TOOLTIP="Returns 'true' when white colour is detected on right side";
Blockly.Msg.MASAYLO_FORWARD_TEXT="Move forward";
Blockly.Msg.MASAYLO_FORWARD_TOOLTIP="Masaylo will move forward until new orders";
Blockly.Msg.MASAYLO_BACKWARD_TEXT="Move backward";
Blockly.Msg.MASAYLO_BACKWARD_TOOLTIP="Masaylo will move backward until new orders";
Blockly.Msg.MASAYLO_LEFT_TEXT="Turn left";
Blockly.Msg.MASAYLO_LEFT_TOOLTIP="Masaylo will turn left (anticlockwise if seen from above) until new orders";
Blockly.Msg.MASAYLO_RIGHT_TEXT="Turn right";
Blockly.Msg.MASAYLO_RIGHT_TOOLTIP="Masaylo will turn right (clockwise if seen from above) until new orders";
Blockly.Msg.MASAYLO_STOP_TEXT="Stop";
Blockly.Msg.MASAYLO_STOP_TOOLTIP="Seems clear enough to me...";
Blockly.Msg.MASAYLO_VELOCIDAD_TEXT="Move at speed: ";
////////////ESCORNABOT Robot////////// ONLY TRANSLATE THE LEFT PART INSIDE ["THIS YES" ,NOT]
Blockly.Msg.ESCORNABOT_MODE_TEXT="Init Escornabot";
Blockly.Msg.ESCORNABOT_MODE_CHOICE= [["Weak", ""], ["Strong", "(2)"], ["Medium", "(3)"]];;
Blockly.Msg.ESCORNABOT_INIT_TOOLTIP="Mode choice: 1-> weaker but less electrical consumption, 2->Stronger, but needs more supply, 3->Intermediate mode ";
Blockly.Msg.ESCORNABOT_URL="https://escornabot.com/es/index";
Blockly.Msg.ESCORNABOT_SPIN="Spin: ";
Blockly.Msg.ESCORNABOT_SPIN_NUMBER="N¬∫: ";
Blockly.Msg.ESCORNABOT_SPIN_TOOLTIP="Indicate spin number(admits negative value if reverse is wanted) and velocity"
Blockly.Msg.ESCORNABOT_SPIN_VELOCITY_TEXT="Velocity: "
Blockly.Msg.ESCORNABOT_SPIN_VELOCITY=[["Slow", "5"], ["Medium", "10"], ["Quick", "15"]];;
Blockly.Msg.ESCORNABOT_DISTANCE="Run distance: ";
Blockly.Msg.ESCORNABOT_DISTANCE_TEXT="cm: ";
Blockly.Msg.ESCORNABOT_DISTANCE_TOOLTIP="Indicate distance in cm (negative values will imply reverse mode) and velocity";
Blockly.Msg.ESCORNABOT_TURNSPIN_TEXT="Turn by X spins: ";
Blockly.Msg.ESCORNABOT_TURNSPIN_TOOLTIP="Turn clockwise/anticlockwise (depending on wether you introduce positive or negative values of spin number you desire)";
Blockly.Msg.ESCORNABOT_TURNANGLE_TEXT="Angle spin: ";
Blockly.Msg.ESCORNABOT_ANGLE_NUMBER="Angle: "
Blockly.Msg.ESCORNABOT_TURNANGLE_TOOLTIP="Spin by angle (sign value means clockwise/anticlockwise)";
Blockly.Msg.ESCORNABOT_STOP_TEXT="Stop";
Blockly.Msg.ESCORNABOT_STOP_TOOLTIP="What did you think?  ";
Blockly.Msg.ESCORNABOT_BEEP_TEXT="Beep";
Blockly.Msg.ESCORNABOT_TIME_TEXT="ms";
Blockly.Msg.ESCORNABOT_BEEP_TOOLTIP="Beeps as long as the time you specify";
Blockly.Msg.ESCORNABOT_LEDON_TEXT="LED ON: ";
Blockly.Msg.ESCORNABOT_LEDOFF_TEXT="LED OFF: ";
Blockly.Msg.ESCORNABOT_LED_CHOICE=[["Forward", "1"], ["Backward", "3"], ["Left", "2"],["Right", "4"]];;
Blockly.Msg.ESCORNABOT_LEDON_TOOLTIP="Lights on the selected LED diode";
Blockly.Msg.ESCORNABOT_LEDOFF_TOOLTIP="Lights off the selected LED diode";
Blockly.Msg.ESCORNABOT_GETBUTTON_TEXT="Button pushed: ";
Blockly.Msg.ESCORNABOT_GETBUTTON_TOOLTIP="Check if the selected button is being pushed.";
Blockly.Msg.ESCORNABOT_BUTTON_SELECTED=[["Forward", "1"], ["Backward", "3"], ["Left", "2"],["Right", "4"],["Center", "5"]];;



Blockly.Msg.ESCORNABOT_APP_TOOLTIP="Autonomous working";
Blockly.Msg.ESCORNABOT_APP_URL="www.escornabot.com";
Blockly.Msg.ESCORNABOT_USINIT_TEXT="Ultrasound inits";
Blockly.Msg.ESCORNABOT_TRIGGER_TEXT="Trigger pin";
Blockly.Msg.ESCORNABOT_ECHO_TEXT="Echo pin";
Blockly.Msg.ESCORNABOT_GETUS_TEXT="Distance";
Blockly.Msg.ESCORNABOT_GETUS_TOOLTIP="Distance";
Blockly.Msg.ESCORNABOT_IRINIT_TEXT="Inits ir";
Blockly.Msg.ESCORNABOT_IR_TOOLTIP="Initialize infrared sensors";
Blockly.Msg.ESCORNABOT_GETBLACKLEFT_TEXT="Black left detected";
Blockly.Msg.ESCORNABOT_GETBLACKLEFT_TOOLTIP=" TRUE if black detected at left side";
Blockly.Msg.ESCORNABOT_GETBLACKRIGHT_TEXT="Black right detected";
Blockly.Msg.ESCORNABOT_GETBLACKRIGHT_TOOLTIP="TRUE if black detected at right side";
Blockly.Msg.ESCORNABOT_GETWHITELEFT_TEXT="White left detected";
Blockly.Msg.ESCORNABOT_GETWHITELEFT_TOOLTIP="TRUE if white detected at left side";
Blockly.Msg.ESCORNABOT_GETWHITERIGHT_TEXT="White right detected";
Blockly.Msg.ESCORNABOT_GETWHITERIGHT_TOOLTIP="TRUE if white detected at right side";
Blockly.Msg.ESCORNABOT_IRLEFT_TEXT="Gauche";
Blockly.Msg.ESCORNABOT_IRRIGHT_TEXT="Droite";
Blockly.Msg.STEPPERCHOICE=[["pas √† pas 1", "s1"], ["pas √† pas 2", "s2"]];
//Les suivants definitions sont √† moi (Pardonnez moi, mon fran√áais c'est tr√®s oxid√©)
Blockly.Msg.matrice8x8_symbole = "d√©finir symbole";
Blockly.Msg.matrice8x8_symbole_tooltip = "D√©finition d'un symbole pour la matrice LED.\n 0 √©teint la LED.\n 1 allume la LED";
Blockly.Msg.matrice8x8_aff="dessiner le symbole";
Blockly.Msg.matrice8x8_aff_tooltip = "Dessine le symbole pr√©c√©demment d√©fini";
Blockly.Msg.matrice8x8_efface="effacer";
Blockly.Msg.rvb_red="rouge";
Blockly.Msg.rvb_green="vert";
Blockly.Msg.rvb_blue="bleu";